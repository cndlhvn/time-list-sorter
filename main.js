/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TimeListSorterPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var TimeListSorterPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("Loading Time List Sorter plugin");
    this.addCommand({
      id: "sort-list-by-time",
      name: "\u9078\u629E\u3057\u305F\u30EA\u30B9\u30C8\u3092\u6642\u523B\u9806\u3067\u30BD\u30FC\u30C8",
      editorCallback: (editor) => {
        this.sortSelectedListByTime(editor);
      }
    });
    this.addCommand({
      id: "sort-all-lists-by-time",
      name: "\u30DA\u30FC\u30B8\u5185\u306E\u3059\u3079\u3066\u306E\u30EA\u30B9\u30C8\u3092\u6642\u523B\u9806\u3067\u30BD\u30FC\u30C8",
      editorCallback: (editor) => {
        this.sortAllListsInPage(editor);
      }
    });
    this.addRibbonIcon("clock", "\u6642\u523B\u9806\u3067\u30EA\u30B9\u30C8\u3092\u30BD\u30FC\u30C8", () => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (activeView) {
        this.sortSelectedListByTime(activeView.editor);
      }
    });
  }
  onunload() {
    console.log("Unloading Time List Sorter plugin");
  }
  sortSelectedListByTime(editor) {
    if (!editor.somethingSelected()) {
      new import_obsidian.Notice("\u30EA\u30B9\u30C8\u3092\u30BD\u30FC\u30C8\u3059\u308B\u306B\u306F\u30C6\u30AD\u30B9\u30C8\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044");
      return;
    }
    const selectedText = editor.getSelection();
    const lines = selectedText.split("\n");
    const listItems = [];
    const nonListLines = [];
    lines.forEach((line, index) => {
      if (this.isListItem(line)) {
        const timeInMinutes = this.extractTimeInMinutes(line);
        listItems.push({
          line,
          timeInMinutes,
          originalIndex: index
        });
      } else {
        nonListLines.push(line);
      }
    });
    if (listItems.length === 0) {
      new import_obsidian.Notice("\u9078\u629E\u7BC4\u56F2\u306B\u30EA\u30B9\u30C8\u9805\u76EE\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3067\u3057\u305F");
      return;
    }
    listItems.sort((a, b) => {
      if (a.timeInMinutes === -1 && b.timeInMinutes === -1) {
        return a.originalIndex - b.originalIndex;
      }
      if (a.timeInMinutes === -1)
        return 1;
      if (b.timeInMinutes === -1)
        return -1;
      return a.timeInMinutes - b.timeInMinutes;
    });
    const sortedLines = listItems.map((item) => item.line);
    if (nonListLines.length > 0) {
      new import_obsidian.Notice(`${listItems.length}\u500B\u306E\u30EA\u30B9\u30C8\u9805\u76EE\u3092\u30BD\u30FC\u30C8\u3057\u307E\u3057\u305F\uFF08\u975E\u30EA\u30B9\u30C8\u884C\u306F\u9664\u5916\u3055\u308C\u307E\u3057\u305F\uFF09`);
    } else {
      new import_obsidian.Notice(`${listItems.length}\u500B\u306E\u30EA\u30B9\u30C8\u9805\u76EE\u3092\u6642\u523B\u9806\u3067\u30BD\u30FC\u30C8\u3057\u307E\u3057\u305F`);
    }
    editor.replaceSelection(sortedLines.join("\n"));
  }
  isListItem(line) {
    const listPattern = /^\s*[-*+]\s*(\[[ x]\]\s*)?/;
    const numberedListPattern = /^\s*\d+\.\s*/;
    return listPattern.test(line) || numberedListPattern.test(line);
  }
  extractTimeInMinutes(text) {
    const timePattern = /(\d{1,2}):(\d{2})/;
    const match = text.match(timePattern);
    if (match) {
      const hours = parseInt(match[1], 10);
      const minutes = parseInt(match[2], 10);
      if (hours >= 0 && hours <= 23 && minutes >= 0 && minutes <= 59) {
        return hours * 60 + minutes;
      }
    }
    return -1;
  }
  sortAllListsInPage(editor) {
    const fullText = editor.getValue();
    const lines = fullText.split("\n");
    const listGroups = this.detectListGroups(lines);
    if (listGroups.length === 0) {
      new import_obsidian.Notice("\u30DA\u30FC\u30B8\u5185\u306B\u30EA\u30B9\u30C8\u9805\u76EE\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3067\u3057\u305F");
      return;
    }
    let totalSortedItems = 0;
    let processedLines = [...lines];
    for (let i = listGroups.length - 1; i >= 0; i--) {
      const group = listGroups[i];
      const groupLines = lines.slice(group.startIndex, group.endIndex + 1);
      const sortedGroup = this.processListGroup(groupLines);
      if (sortedGroup.sortedItems > 0) {
        processedLines.splice(group.startIndex, group.endIndex - group.startIndex + 1, ...sortedGroup.lines);
        totalSortedItems += sortedGroup.sortedItems;
      }
    }
    editor.setValue(processedLines.join("\n"));
    new import_obsidian.Notice(`${listGroups.length}\u500B\u306E\u30EA\u30B9\u30C8\u30B0\u30EB\u30FC\u30D7\u3067${totalSortedItems}\u500B\u306E\u9805\u76EE\u3092\u6642\u523B\u9806\u3067\u30BD\u30FC\u30C8\u3057\u307E\u3057\u305F`);
  }
  detectListGroups(lines) {
    const groups = [];
    let currentGroupStart = null;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      if (this.isListItem(line)) {
        if (currentGroupStart === null) {
          currentGroupStart = i;
        }
      } else {
        if (currentGroupStart !== null) {
          groups.push({
            startIndex: currentGroupStart,
            endIndex: i - 1
          });
          currentGroupStart = null;
        }
      }
    }
    if (currentGroupStart !== null) {
      groups.push({
        startIndex: currentGroupStart,
        endIndex: lines.length - 1
      });
    }
    return groups;
  }
  processListGroup(groupLines) {
    const listItems = [];
    const nonListLines = [];
    groupLines.forEach((line, index) => {
      if (this.isListItem(line)) {
        const timeInMinutes = this.extractTimeInMinutes(line);
        listItems.push({
          line,
          timeInMinutes,
          originalIndex: index
        });
      } else {
        nonListLines.push(line);
      }
    });
    if (listItems.length === 0) {
      return { lines: groupLines, sortedItems: 0 };
    }
    listItems.sort((a, b) => {
      if (a.timeInMinutes === -1 && b.timeInMinutes === -1) {
        return a.originalIndex - b.originalIndex;
      }
      if (a.timeInMinutes === -1)
        return 1;
      if (b.timeInMinutes === -1)
        return -1;
      return a.timeInMinutes - b.timeInMinutes;
    });
    const sortedLines = listItems.map((item) => item.line);
    return {
      lines: sortedLines,
      sortedItems: listItems.length
    };
  }
};
